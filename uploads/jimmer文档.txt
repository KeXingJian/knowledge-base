核心功能 ✦
为了便于读者更好地理解核心功能，先介绍Jimmer的根本设计理念

设计理念
Jimmer的核心理念，在于任意形状的的数据结构作为一个整体进行读写操作，而非简单的处理实体对象。

Jimmer实体对象并非POJO，可轻松。

任意形状的数据结构，都可以作为一个整体进行

读：Jimmer创建这种无限灵活的数据结构，传递给你

写：你创建这种无限灵活的数据结构，传递给Jimmer

既然Jimmer的设计理念是为了读写任意形状的数据结构，而非处理简单的对象，那么它具备类似能力的技术有什么差异呢？

比较	描述
GraphQL	GraphQL通过HTTP为客户端提供服务；而在Jimmer中，这是无处不在的框架API行为，无需任何服务即可直接享用
GraphQL只关注查询任意形状的数据结构；Jimmer不仅如此，还关注如何写入任意形状的数据结构
GraphQL不支持基于自关联属性的递归查询，Jimmer支持
JPA	JPA中，为控制被保存数据结构的形状，必须为使属性配置insertable、updatable或cascade(针对关联属性)， 无论如何配置，被保存的数据结构是固定的；Jimmer实体并非POJO，其数据结构的形状千变万化， 无需事先规划和设计，任何业务场景都可以构建它需要的数据结构并直接保存
对于查询而言，JPA的EntityGraphQL非常复杂；Jimmer提供了两种手段来实现类似的功能： 控制返回实体对象的格式，或者通过极其廉价的方式生成DTO并直接查询，无论哪种方式，都远比EntityGraph简单
在JPA中，如果需要为只查询部分属性而使用DTO对象，那么DTO必须是一个没有任何关联简单对象。即，丢失了ORM最宝贵的能力，从ORM退化成了OM； Jimmer自动生成的DTO支持任意复杂的层级关系，Jimmer是目前唯一一个支持基于DTO的嵌套投影的ORM

在JPA中，更新对象会导致所有可更新的列被修改。为了简便，开发人员很少使用update，选择先查询完整的对象，修改部分属性，最后保存整个对象；Jimmer可以构建并直接保存残缺对象

JPA的EntityGraphQL不支持基于自关联属性的递归查询，Jimmer支持
MongoDB	
在MonoDB中，每个文档结构都是一个数据孤岛。虽然MongoDB的数据结构是弱类型的，但从业务层面讲，有哪些数据孤岛以及每个数据孤岛内部的层级结构需要实现设计和约定。 一旦完成设计和约定，整个数据视图的格式就定死了，必须按照固定的视角处理数据； 在Jimmer中，数据结构的形状无需实现设计，任何业务场景都可以随意规划出一个数据结构的格式，并将对应的数据结构作为一个整体进行读写。

提示
基于此核心理念，Jimmer将会为你带来以前在任何技术路线想都难以企及的便捷性， 这会让你从繁琐的细节处理中解脱出来，专注于复杂业务的快速实现。

功能列表
基于上述核心价值，Jimmer提供如下功能

便捷的查询API，健全的Java DSL，优美的Kotlin DSL
动态查询为多表查询设计
DSL支持混入原生SQL表达式，以使用非标准的数据库特有能力
支持Derived Table, CTE和Recursive-CTE这样的高级SQL
拓展SQL的能力，轻松支持原生SQL实现成本高昂的高级功能
高级的SQL优化能力
自动去除无用的表连接
自动合并逻辑等价的表连接
自动合并逻辑等价的隐式子查询
分页查询可自动生成并优化count查询
DTO语言，以及相应的编译时代码生成器，让DTO变得极其廉价
Output DTO，用作复杂查询的返回
Input DTO, 用作复杂保存的参数
Specification DTO, 用作复杂查询的参数
ORM自身支持的DTO可以与其无缝集成，不会为业务代码引入额外逻辑
查询任意图结构
没有N + 1问题
任何层次的对象都可以不完整
可递归查询自关联属性
既可以直接返回实体，也可返回Output DTO
保存任意图结构
利用数据库本身的upsert能力merge数据
每一层的多个对象都用批量DML操作
自动翻译违背约束的异常
任何层次的被保存对象都可以不完整
既可以直接保存实体，也可保存Input DTO
强大的缓存
多级缓存，每一级缓存都可以做自由技术选型
不仅仅是对象缓存 (关联、计算值、多视图)
自动维持缓存一致性
对GraphQL的快速支持
基于文档注释客户端契约 (OpenAPI、TypeScript)


项目介绍 ✦
1. Jimmer是什么?
Jimmer是JVM中最先进的ORM，同时面向Java和Kotlin

ORM核心

所有读写相关API，都为操作任意复杂的数据结构而设计，而非为操作简单对象而设计

实体对象可以是残缺的的，即使任何读写操作都可以只针对对象的部分属性，而非所有属性
直接读写任意复杂的数据结构，数据结构的层次和形状由具体业务场景随意指定，无需事先统一固化设计
为批量操作而设计

查询功能没有N + 1问题，即使实体对象具备用户自定义的复杂的业务计算属性，仍然如此
充分发挥底层数据批量修改的能力，被保存数据结构的每一层对象都采用JDBC批量操作
充分发挥底层数据库的upsert能力，尽可能避免复杂批量修改中夹带select语句，如果无法做到，清晰地告诉用户为什么
即使执行复杂的批量修改，对常见的数据库约束错误进行细致的调查的翻译，业务项目亲自处理数据库约束异常成为历史
强类型DSL支持

强类型DSL和使用数据库特有能力不冲突，你仍然可以使用特定数据库产品的特有功能
为任意复杂的多表动态查询而设计，一改业内绝大部分动态查询方案都是针对单表操作的现状
智能优化生成的SQL
不仅为了生成SQL，更是为了超越Native SQL，提供更便捷的能力
以此ORM为基础打造了一套综合性方案解决方案，包括

DTO语言，以极其廉价的成本解决多数情况下业务模型和数据模型不完全一致的问题
更全面更强大的缓存机制，以及高度自动化的缓存一致性
更强大客户端文档和代码生成能力，包括Jimmer独创的远程异常
快速创建GraphQL服务
跨越微服务的远程实体关联
目前未完成，但1.0.0会支持的功能

支持子查询作为from或join的基表
支持更强大的非对象查询API
支持实体模型的继承和多态
支持外键引用非id属性
2. 一个新的ORM，为什么？
现有痛点
当前技术生态下，访问关系型数据库技术体系存在很大缺陷，请看下图。

mirror

以JPA为代表的静态语言ORM 

以为ActiveRecord (Ruby) 为代表的动态语言ORM 

以MyBatis为代表的轻量级SQL Builder/Mapper 

根本原因
上文中，我们阐述了关系型数据库领域的三种常见方案，但无论如何选择，我们都无法兼顾便捷性、灵活性和代码安全性。为什么会导致这样呢？

信息
就JVM生态而言，POJO是导致这个问题的根本原因。

POJO*(也可以叫结构体)*缺乏必要的灵活性和表达力，却几乎被所有的JVM框架作为数据模型和核心，严重限制了JVM生态的技术创新。

因此，在Jimmer中，ORM实体对象并非POJO。而是另外一种独特的万能数据对象*(后文会介绍)*，这种独特的实体对象撑起了Jimmer所有上层重大的变革，是整个框架的基石。

备注
事实上，Jimmer实体对象不仅可以应用在ORM领域，它几乎可以用在任何以结构化数据维护为目的的场景，并提升各种技术栈的表达力。

目前，Jimmer实体仅在关系型数据库访问领域发挥出作用，只是因为精力不够所致。

3. 完整的功能
mirror

3.1. Business Model
在信息类系统中，存在两种对象。

实体：实体对象是全局统一的，对象之间的存在丰富彼此关联。

实体对象往往和数据库非常接近，具备极高的稳定性。

DTO：针对特定业务的输入/输出对象，通常是从全局实体关系网上撕下来的一个局部碎片，该碎片的大小和形状非常灵活。

DTO类型数量庞大，每一个业务接口对DTO对象的格式都有独特的需求，彼此可能相似但又不同，具备明显的。而且易受到需求变化的影响，不稳定。

提示
Entity类型是全局统一数据存储模型，不易被需求变更影响，相对稳定，被视为高价值类型。

DTO类型作为每个业务输入/输出，相对随意，容易因需求变动而不稳定，被视为低价值类型。

Jimmer主张开发人员把精力集中在高价值的实体模式的设计上；对于低价值的DTO类型，有的时候并不需要，有的时候需要。 即使需要，也可以用极其廉价的方式自动生成。因此，基于Jimmer构建的项目具备优秀的抗需求变动的能力。

3.1.1. Jimmer Entity
Jimmer实体定义和JPA实体很接近。

之前讨论过，Jimmer实体并非POJO，所以，被声明为interface，而非class。

那么，谁负责实现此接口呢？是上图中的Jimmer Precompiler (对于Java而言，就是APT； 对于Kotlin而言，就是KSP)

Jimmer实体支持两个重要特征，动态性和不可变性

动态性

Jimmer对象在静态语言和动态语言之间寻求最佳平衡，把二者的优点结合起来：

静态语言数据对象具有高性能、拼写安全、类型安全、甚至空安全*(如果使用Kotlin的话)*的优点，Jimmer实体吸收了这些优点。

动态语言数据对象具有高度的灵活性，Jimmer实体吸收了这个优点，每个属性都可以缺失*(但是不能如同动态语言一样增加属性，因为这必然会破坏静态语言的特性，Jimmer也不需要此能力)*

对Jimmer而言，对象缺少某个属性 (其值未知) 和 对象的某个属性为null (其值已知) 是完全不同的两回事。

提示
这种平衡设计，可以在享受静态语言好处的同时，为数据结构赋予。

这种绝对的灵活性，既可用于表达查询业务的输出格式，也可用于表达保存业务的输入格式。

这导致Jimmer拥有了崭新的定位：一个为任意形状数据结构设计的ORM。其所有功能都是为了操作任意形状的数据结构，而非一个个简单的实体对象。

不可变性

Jimmer对象是不可变对象。不可变对象的好处是多方面的，相关文章和论述非常多，本文不做重复性讨论。

提示
Jimmer选择不可变对象是为了让数据结构绝不包含循环引用。

这可以保证由Jimmer实体及彼此关联组合而成的数据结构一定能够被直接Jackson序列化，并不需要使用诡异的序列化技巧为JSON植入任何特殊的额外信息，任何编程语言都可以轻松理解。

然而，不可变对象也存在缺点。比如，现有一个很深的数据结构，那么基于它按照一些修改的愿望创建出新的数据结构会很困难，难度随着深度的变大急剧增加。

ORM和很深的数据结构打交道，而Java的record和Kotlin的data class不适合处理很深数据结构。

既对Java和Kotlin进行双语支持，又善于基于现有深层次数据结构按照一些修改的愿望创建出新的不可变数据结构的方案，目前的JVM生态没有。

幸运的是，JavaScript/TypeScript领域存在一个足够强大的方案: immer，可以完美解决这个问题。该方案工作方式如下

基于现有不可变数据结构开启一个临时作用域。

在这个作用域内，开发人员可得到一个draft数据结构，该数据结构的形状和初始值和原数据结构完全一致，且可以被随意修改，包括修改任意深的子对象。

作用域结束后，draft数据结构会利用收集到的修改行为创建另外一个新的数据结构。其中，未被修改的局部会被优化处理，复用以前的旧对象。

Immer完美结合了不可变对象和可变对象的优点，代码简单、功能强大、性能卓越。因此，Jimmer选择为JVM生态移植了immer，项目名称也是对其致敬。

参考链接: 动态性，不可变性

3.1.2. Generated DTO Type
前文谈到，Jimmer实体在静态语言数据对象和动态语言数据对象之间寻找最佳平衡，其中动态性带来了极大的灵活性，并以此决定了整个框架的定位。

Jimmer对象允许某些属性缺失，对象缺少某个属性 (其值未知) 和 对象的某个属性为null (其值已知) 是完全不同的两回事。

对于Jackson序列化而言，缺失的属性会被自动忽略，就如同我们之前展示的那样。

如果服务端自己并不使用查询得到的实体对象，而是直接写入到Http Response中。对于这种情况，无需DTO，直接使用实体对象很方便。

如果直接用Java/Kotlin代码访问不存在的属性，会导致异常。

如果服务端自己要使用查询得到的实体对象，这会带来风险，尽管Jimmer实体在其他方面依旧保留了静态语言的特色，比如拼写安全、类型安全、甚至空安全*(如果使用kotlin)*。

以JPA为例，从Hibernate3开始，lazy配置不再局限于关联属性，而是可以用于标量属性。后来演化为JPA之@Basic注解的fetch参数， 请参考这这里。

这和Jimmer对象任何属性都可以缺失有一定相似性，只是Jimmer将此特征推广到了任何属性。所以，Jimmer的这个异常和org.hibernate.LazyInitializationException有一定相似性。

所以，这并非由Jimmer制造的新问题，而是一个在静态语言ORM生态中早已存在和被接受的问题。然而，不可否认这的确对静态语言的安全性形成了破坏。

如果要追求100%的静态语言安全性，使用DTO对象是唯一的方法。然而，目前JVM生态的DTO映射技术存在很大缺陷。

要么显式地映射属性*(例如纯手工映射和转化)*，这种做法工作量巨大，枯燥且容易出错。
要么隐式地映射属性*(例如采用BeanUtils技术)*，这种做法会引入新的不安全问题，即，无法在编译发现的问题。
即使你使用强大的mapstruct，你所能做的也只是在这两个极端之间作出选择而已。

因此，Jimmer提供了DTO语言，用户使用该语言编写非常简单的代码，编译项目即可自动生成各种丰富的DTO类型定义。

提示
DTO语言的设计目的，在于

让生成DTO类型的过程足够简单，从而让DTO类型足够廉价。

100%符合静态语言安全性，在编译时发现所有问题并报错。

在任何子项目中 (并不限制为实体定义子项目)，开发人员都可以在src/main/dto目录下随意建立扩展名为dto的文件， 廉价的自动生成各种DTO类型。

这种以极低成本快速生成的DTO类型可以和Jimmer实体对象彼此转换；因此，任何两种DTO类型都可以以Jimmer实体为中间媒介彼此转换。

参考链接：DTO语言

3.2. Fetcher ★
提示
Fetcher，是Jimmer三个最基础的核心功能之一 (另外两个是Save Command和SQL DSL)。

Jimmer为查询任意形状的数据结构而设计，能像GraphQL那样细腻地控制被查询数据的格式。

首先，通过这个动画来感受一下Jimmer随意控制被查询数据结构形状的能力 (建立初步印象即可，不用看得太细)。 

前文提到，既可以直接使用实体对象，也可以使用被廉价生成的DTO对象。Fetcher对这两种数据对象的查询都提供了一流的支持。让我们通过3个场景来展示其用法

查询残缺对象

所谓残缺对象，就是指查询对象的部分属性，其信息量还不如一个孤单对象丰富 。

附带关联对象

选定一个实体作为聚合根，不但要查询聚合根对象，还要查询其关联对象，且深度和广度都不受限制，这种格式控制能力的细腻程度和GraphQL一样 。

递归查询

如果实体包含自关联属性，可以进行递归查询 (截止到目前为止，GraphQL不支持递归查询) 。

信息
用户应该积极地使用该功能查询任意复杂的数据结构，而非自己编写业务代码去获取不同部分的数据再拼接成一个整体，因为Fetcher具有如下很难用业务代码替代的优势：

不但能处理关联属性，还能处理复杂计算属性
能充分利用的Jimmer的 和大幅优化查询复杂数据结构的性能
实体支持远程关联，即，跨越微服务边界的ORM关联，Jimmer自动从不同的微服务查询数据并组装成一个数据结构
整个层层深入的过程由广度递归驱动，以支持批量查询优化
无需开发人员做任何工作，ORM本身就具备了可媲美GraphQL的强大能力。所以，无论用Jimmer来构建REST服务，还是GraphQL服务，查询相关任务都非常简单。

快速构建REST服务

由服务端控制返回对象的形状。如果某个HTTP API需要返回的数据结构形状是什么，开发人员都有两种选择：直接使用实体类型，或用DTO语言廉价地生成DTO类型。

无论如何选择，客户端都是被动地接受服务端返回的数据格式。即使，客户端需要的数据结构形状种类非常多，对基于Jimmer开发的服务端影响很小。

如果开发人员选择直接返回实体对象而非DTO。这时服务端没有， 这对服务端不是问题；但是对于客户端而言，这是非常糟糕的。

Jimmer为客户端生成Open Api文档和TypeScript代码，如果服务端开发人员选择直接返回实体对象， 则可用@FetchBy注解修饰Web方法的返回类型，即可在Open Api和TypeScript代码中为客户端定义DTO类型。

快速构建GraphQL服务

通常情况下，提供GraphQL服务工作量不小，开发人员要花很大的精力去支持GraphQL对象之间丰富的关联。

然而，基于Jimmer实现GraphQL是非常容易的，因为ORM本身已经有了和GraphQL类似的能力，开发人员只需为GraphQL查询API实现聚合根对象的查询即可，GraphQL对象之间丰富的关联由Jimmer自动实现。

参考连接
3.3. Save Command ★
提示
Save Command，是Jimmer三个最基础的核心功能之一 (另外两个是Fetcher和SQL DSL)。

保存指令专为为复杂表单设计。无论表单多么复杂，本质上就是任意形状的数据结构，Jimmer让开发人员只需使用一个方法调用就可以把任意形状的数据结构写入数据库。

无论用户传入的数据结构的复杂度如何，Jimmer都会从数据库查询出同等复杂度的数据结构并找出二者差异 (这并非真正的工作机制，但是从用户视角如此理解这个功能没问题)， 并执行insert、update和delete语句更新不一样的地方。

然而，如果允许客户端上传代表任意形状的数据结构的实体对象，那么客户端将获得不受限制的数据修改能力，这会严重破安全性。所以，必须通过DTO语言生成Input DTO，再用Input DTO作为Web Api的输入参数。即

动态实体作为内部机制，让保存指令能保存任意形状的数据结构，从功能层面支持无限种可能。

Input DTO作为安全卫士，严格限制用户的输入格式，只对外暴露有限的数据录入能力。

接下来，我们通过4个案例，展示保存指令的基本用法:

保存孤单对象

这是最简单的情况，因为孤单的对象不存在任何关联数据。

保存短关联

所谓短关联，指只改变当前对象和其他对象之间的关联关系，不进一步修改关联对象。 对于UI界面而言，引用关联 (一对一和多对一) 表现为单选菜单； 集合关联 (一对多和多对多) 表现为多选菜单 。 

保存长关联

所谓长关联，指不仅要改变当前对象和其他对象之间的关联关系，还要进一步修改关联对象。 对于UI界面而言，形式多样，以表单内嵌子表最为常见 (一对多) ： 

递归保存树形结构

这个例子稍有不同，需要在保存之前稍微需改一下根节点的数据。

参考连接
3.4. SQL DSL ★
提示
SQL DSL，是Jimmer三个最基础的核心功能之一 (另外两个是Fetcher和Save Command)。

Jimmer SQL DSL为任意复杂的动态SQL而设计。

现在，整个JVM生态有几十种SQL DSL。其中，以ORM风格的QueryDSL和NativeSQL风格的JOOQ最为有名。那么Jimmer的SQL DSL有什么特色呢？

Jimmer的SQL DSL天生为任意复杂的动态SQL而设计，包括两个强大的能力：动态表连接、隐式子查询。

原生SQL并不利于构建复杂的动态查询，Jimmer SQL DSL的目的是对此给出相应的方案；而所有SQL DSL都能做到的强类型安全性只是附带效果。

非常智能的分页支持，开发人员只需要用DSL构建普通的列表查询，Jimmer自动生成分页前的总行数查询，并自动结合二者完成分页查询。

Jimmer的SQL DSL可以嵌入原生SQL表达式。

篇幅有限，本文只讨论上面的第一点。让我们通过三个小例子来了解Jimmer SQL DSL的基本能力:

简单的动态查询

简单的动态查询，建立初步印象。

动态表连接

为引用关联 (一对一或多对一) 属性的关联对象动态添加SQL条件。

隐式子查询

Jimmer支持功能更完整的普通子查询。但是，一部分因实体关联紧密相关的子查询可以写成这种更简单的隐式子查询。

为集合关联 (一对多或多对多) 属性的关联对象动态添加SQL条件。

提示
事实上，用户还可以利用DTO语言的编写specification DTO，让Jimmer自动生成查询条件参数，以及你在上面看到的所有动态查询行为。

这个更为便捷的功能叫超级QBE。这里，我们采用这个功能来替代上面介绍过的所有功能。

参考链接
3.5 Trigger
这个功能类似于数据库的后置触发器，在数据库变更发生后通知应用程序。

Trigger不但能通知开发人员哪些实体对象发生了什么变化，还对变化事件的信息做了ORM映射，以通知开发人员哪些实体关联发生了变化。

Trigger为另外一个功能：缓存，打下了坚实的基础。

Jimmer支持两种各不同类型的触发器: BinLog触发器和Transaction触发器

BinLog触发器	Transaction触发器(默认关闭)
工作原理	通过整合业内成熟的CDC方案(比如：maxwell，debezium)发现数据的变化	靠Jimmer自身的能力发现数据库的变化
通知时机	事务提交后	事务提交前
优点	能感知因任何原因导致的数据库变化，包括绕过系统的数据库变化	原变更和触发器导致的新变更要么都成功要么都失败
缺点	事务提交后，CDC服务推送存在轻微延迟	只能感知当前JVM进程自己通过Jimmer对数据库的修改导致的变更，对其他任何原因导致的数据库变更无能为力
当前事务的持续时间会被拖长，相关资源的的解锁操作也会被滞后
会导致Jimmer对数据库的修改行为内部需要更多的额外查询
适用场景	绝大部分场景，包含但不限于：缓存同步，异构系统数据同步	必须和主业务参与同一个事务的附加行为
参考链接：触发器
